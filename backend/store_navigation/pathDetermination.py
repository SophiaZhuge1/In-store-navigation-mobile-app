import pandas as pd


"""
load_store
- Function used to load the layout and metadata for a store

Parameters:
- zeros_in_layout: A boolean to state whether 0 values are used instead of empty values to represent a lack of 
    connection between nodes
- has_header: A boolean to state whether the layout contains a header line or not

Outputs:
- Returns a tuple with the first variable being a list of integers representing the path from start node
"""


def load_store(zeros_in_layout=False, has_header=True):
    if not has_header:
        layout = pd.read_csv("data/store_layout.csv", header=None)
        layout.columns = [str(i) for i in list(range(layout.shape[0]))]
    else:
        layout = pd.read_csv("data/store_layout.csv")

    if zeros_in_layout:
        layout.replace([0], float('inf'), inplace=True)

    metadata = pd.read_csv("data/store_metadata.csv")
    entrance_node = metadata.iat[0, 1]
    checkout_node = metadata.iat[0, 2]

    return (layout, entrance_node, checkout_node)


"""
find_shortest_path
- Function used to find the shortest path between two nodes using an implementation of Dijkstra's Algorithm

Parameters:
- matrix: A panda dataframe representing the entire store as generated by load_store()
- start_node: Integer representing the starting node for the path
- end_node: Integer representing the destination node for the path 

Outputs:
- Returns a tuple with the first variable being a list of integers representing the path from start node
"""


def find_shortest_path(matrix, start_node, end_node):
    distanceToNode = []
    previousNode = []
    for i in range(matrix.shape[0]):
        distanceToNode.append(float('inf'))
        previousNode.append(None)

    distanceToNode[start_node] = 0
    unoptimised_nodes = list(range(matrix.shape[0]))

    while end_node in unoptimised_nodes:
        nodeWithMinDistance = None
        currentMinDistance = float('inf')
        for node in unoptimised_nodes:
            if distanceToNode[node] < currentMinDistance:
                currentMinDistance = distanceToNode[node]
                nodeWithMinDistance = node

        unoptimised_nodes.remove(nodeWithMinDistance)
        if nodeWithMinDistance == end_node:
            break

        headersToFilter = [str(i) for i in unoptimised_nodes]
        connectionsToNeighbours = matrix.loc[nodeWithMinDistance, headersToFilter]
        connectionsToNeighbours.dropna(inplace=True)
        connectionsToNeighbours = pd.to_numeric(connectionsToNeighbours)
        neighbours = list(connectionsToNeighbours.index.values)

        for i in range(len(neighbours)):
            newDistance = currentMinDistance + connectionsToNeighbours[i]
            if newDistance < distanceToNode[int(neighbours[i])]:
                distanceToNode[int(neighbours[i])] = newDistance
                previousNode[int(neighbours[i])] = nodeWithMinDistance

    lastNodeInPath = previousNode[end_node]
    pathToEnd = [end_node]
    while lastNodeInPath != start_node:
        pathToEnd.insert(0, lastNodeInPath)
        lastNodeInPath = previousNode[lastNodeInPath]

    return (pathToEnd, distanceToNode[end_node])


"""
generate_reduced_matrices
- Function used to generate two matrices that represent a reduced graph that is only between the nodes that have items
    and the entrance

Parameters:
- matrix: A panda dataframe representing the entire store as generated by load_store()
- item_locations: List of integers representing all the nodes that have items that need to be picked up
- entrance_node: Integer representing the node where the store entrance is 

Outputs:
- Returns a tuple containing two panda dataframes
- First being a matrix containing each path between nodes as a list of integers
- Second being a matrix with the distance between each node as an integer
"""


def generate_reduced_matrices(matrix, items_locations, entrance_node):
    distanceDataDictionary = {}
    distanceDummyRow = []
    pathDataDictionary = {}
    pathDummyRow = []
    items_locations.append(entrance_node)

    for i in range(len(items_locations)):
        distanceDummyRow.append(float('inf'))
        pathDummyRow.append([])

    for node in items_locations:
        distanceDataDictionary[str(node)] = distanceDummyRow
        pathDataDictionary[str(node)] = pathDummyRow

    distanceMatrix = pd.DataFrame(distanceDataDictionary, index=[str(i) for i in items_locations])
    pathMatrix = pd.DataFrame(pathDataDictionary, index=[str(i) for i in items_locations])

    pathsToCalculate = []
    for i in range(len(items_locations) - 1):
        for j in range(i + 1, len(items_locations)):
            pathsToCalculate.append((items_locations[i], items_locations[j]))

    for pathTuple in pathsToCalculate:
        currentOptimalPath = find_shortest_path(matrix, pathTuple[1], pathTuple[0])
        pathMatrix.at[str(pathTuple[1]), str(pathTuple[0])] = currentOptimalPath[0]
        distanceMatrix.at[str(pathTuple[1]), str(pathTuple[0])] = currentOptimalPath[1]

        currentOptimalPath = find_shortest_path(matrix, pathTuple[0], pathTuple[1])
        pathMatrix.at[str(pathTuple[0]), str(pathTuple[1])] = currentOptimalPath[0]
        distanceMatrix.at[str(pathTuple[0]), str(pathTuple[1])] = currentOptimalPath[1]

    return (pathMatrix, distanceMatrix)


"""
nearest_neighbour_path
- Function used to generate a semi-optimal path from the entrance node and all the items in the store

Parameters:
- pathMatrix: A panda dataframe representing the reduced paths between each node an item is within and the entrance node
- pathMatrix: A panda dataframe representing the distance between each node an item is within and the entrance node
- entrance_node: Integer representing the node where the store entrance is 

Outputs:
- Returns a tuple with the first variable being a list of integers representing the path through the store, and the 
    second being the distance
"""


def nearest_neighbour_path(pathMatrix, distanceMatrix, entrance_node):
    nextNode = str(entrance_node)
    pathThroughShop = [entrance_node]
    distance = 0

    while pathMatrix.shape[0] > 1:
        prevNode = nextNode
        nextNode = str(distanceMatrix[nextNode].idxmin())
        pathThroughShop = pathThroughShop + pathMatrix.at[prevNode, nextNode]
        distance = distance + distanceMatrix.at[prevNode, nextNode]

        headers = list(pathMatrix.columns.values)

        pathMatrix.drop(prevNode, axis=1, inplace=True)
        distanceMatrix.drop(prevNode, axis=1, inplace=True)
        pathMatrix.drop(index=prevNode, inplace=True)
        distanceMatrix.drop(index=prevNode, inplace=True)

    return (pathThroughShop, distance)


"""
get_optimal_path_through_store
- Function that wraps the entire path searching process as one call

Parameters:
item_list: List of integers representing all the nodes that have items that need to be picked up

Outputs:
- Returns a tuple with the first value returning the path from the entrance to all the items on the list, and the second
    being the path from the last item to the checkout
- The path to checkout does not include the node the last item was in and starts from the first node to move into to get
    to the checkout
"""


def get_optimal_path_through_store(item_list):
    storeTuple = load_store(True, False)
    print("Reducing Matrix...")
    reducedMatrices = generate_reduced_matrices(storeTuple[0], item_list, storeTuple[1])
    print("\nBest Paths: ")
    print(reducedMatrices[0])
    print("\nBest Distances: ")
    print(reducedMatrices[1])
    print("\nFinding Optimal Path...")
    bestPath = nearest_neighbour_path(reducedMatrices[0], reducedMatrices[1], storeTuple[1])
    pathToCheckout = find_shortest_path(storeTuple[0], int(bestPath[0][len(bestPath[0]) - 1]), storeTuple[2])

    return (bestPath[0], pathToCheckout[0])

"""
Check to run the script

result = get_optimal_path_through_store([2, 4])
print("Done!")
"""
